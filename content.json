{"meta":{"title":"czw","subtitle":"subtitile of czw","description":"","author":"czw","url":"http://example.com","root":"/"},"pages":[{"title":"文章归档","date":"2023-02-04T00:47:46.289Z","updated":"2023-02-02T09:13:35.800Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"","date":"2023-02-03T03:23:49.649Z","updated":"2023-02-03T03:23:49.643Z","comments":true,"path":"about.html","permalink":"http://example.com/about.html","excerpt":"","text":"我是czw华电的计科的"},{"title":"","date":"2023-02-04T01:49:19.764Z","updated":"2023-02-04T01:49:19.764Z","comments":true,"path":"PY.html","permalink":"http://example.com/PY.html","excerpt":"","text":"四海之内皆兄弟哈哈哈"},{"title":"","date":"2023-02-04T01:52:25.025Z","updated":"2023-02-04T01:52:25.025Z","comments":true,"path":"donate.html","permalink":"http://example.com/donate.html","excerpt":"","text":""}],"posts":[{"title":"Django数据库操作","slug":"Django数据库操作","date":"2023-02-06T09:16:46.016Z","updated":"2023-02-06T09:23:37.682Z","comments":true,"path":"2023/02/06/Django数据库操作/","link":"","permalink":"http://example.com/2023/02/06/Django%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"","text":"pycharm链接数据库(MySQL)123456三个位置查找数据库相关 右侧上方database 左下方database 配置里面的plugins插件搜索安装 需要提前创建好库 django链接数据库(MySQL)12345678910111213141516171819202122232425262728# 默认用的是sqlite3DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;, &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;), &#125;&#125;# django链接MySQL 1.第一步配置文件中配置 DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;day60&#x27;, &#x27;USER&#x27;:&#x27;root&#x27;, &#x27;PASSWORD&#x27;:&#x27;admin123&#x27;, &#x27;HOST&#x27;:&#x27;127.0.0.1&#x27;, &#x27;PORT&#x27;:3306, &#x27;CHARSET&#x27;:&#x27;utf8&#x27; &#125;&#125; 2.代码声明 django默认用的是mysqldb模块链接MySQL 但是该模块的兼容性不好 需要手动改为用pymysql链接 # 在项目名下的init或者任意的应用名下的init文件中书写以下代码都可以 import pymysql pymysql.install_as_MySQLdb() Django ORM、表的建立1234567891011121314151617181920212223242526272829303132333435363738394041424344&quot;&quot;&quot;ORM. 对象关系映射作用:能够让一个不用sql语句的小白也能够通过python 面向对象的代码简单快捷的操作数据库不足之处:封装程度太高 有时候sql语句的效率偏低 需要你自己写SQL语句应用下面的models.py文件&quot;&quot;&quot;# 1 先去models.py中书写一个类 class User(models.Model):#这里得继承，别忘了 # id int primary_key auto_increment id = models.AutoField(primary_key=True) # username varchar(32) username = models.CharField(max_length=32) # password int password = models.IntegerField()*************************# 2 数据库迁移命令*************************python3 manage.py makemigrations 将操作记录记录到migrations文件夹中python3 manage.py migrate 将操作真正的同步到数据库中# 只要你修改了models.py中跟数据库相关的代码 就必须重新执行上述的两条命令******************************************************************class User(models.Model): # id int primary_key auto_increment id = models.AutoField(primary_key=True,verbose_name=&#x27;主键&#x27;) # username varchar(32) username = models.CharField(max_length=32,verbose_name=&#x27;用户名&#x27;) &quot;&quot;&quot; CharField必须要指定max_length参数 不指定会直接报错 verbose_name该参数是所有字段都有的 就是用来对字段的解释 &quot;&quot;&quot; # password int password = models.IntegerField(verbose_name=&#x27;密码&#x27;)class Author(models.Model): # 由于一张表中必须要有一个主键字段 并且一般情况下都叫id字段 # 所以orm当你不定义主键字段的时候 orm会自动帮你创建一个名为id主键字段 # 也就意味着 后续我们在创建模型表的时候如果主键字段名没有额外的叫法 那么主键字段可以省略不写 # username varchar(32) username = models.CharField(max_length=32) # password int password = models.IntegerField() 字段的增删改查12345678910111213141516171819# 字段的增加1.可以在终端内直接给出默认值2.该字段可以为空 info = models.CharField(max_length=32,verbose_name=&#x27;个人简介&#x27;,null=True)3.直接给字段设置默认值 hobby = models.CharField(max_length=32,verbose_name=&#x27;兴趣爱好&#x27;,default=&#x27;study&#x27;) # 字段的修改 直接修改代码然后执行数据库迁移的两条命令即可# 字段的删 直接注释对应的字段然后执行数据库迁移的两条命令即可 执行完毕之后字段对应的数据也都没有了 &quot;&quot;&quot;在操作models.py的时候一定要细心 千万不要注释一些字段 执行迁移命令之前最好先检查一下自己写的代码&quot;&quot;&quot; 数据的增删改查12345678910111213141516171819202122232425262728293031323334353637# 查res = models.User.objects.filter(username=username)&quot;&quot;&quot;返回值你先看成是列表套数据对象的格式它也支持索引取值 切片操作 但是不支持负数索引它也不推荐你使用索引的方式取值user_obj = models.User.objects.filter(username=username).first()取到的是与记录相关的对象的列表的第一个元素，可以通过user_obj.username 或 user_obj.password (user_obj.字段名)取到对应的属性&quot;&quot;&quot;filter括号内可以携带多个参数 参数与参数之间默认是and关系你可以把filter联想成where记忆如果符合条件的有多条记录，那么user_obj列表中的元素就有多个，可以通过索引取值# 增from app01 import modelsres = models.User.objects.create(username=username,password=password)# 返回值就是当前被创建的对象本身# 第二种增加user_obj = models.User(username=username,password=password)user_obj.save() # 保存数据# 修改数据方式1models.User.objects.filter(id=edit_id).update(username=username,password=password)将filter查询出来的列表中所有的对象全部更新 批量更新操作只修改被修改的字段# 修改数据方式2edit_obj.username = usernameedit_obj.password= passwordedit_obj.save()上述方法当字段特别多的时候效率会非常的低，因为它从头到尾将数据的所有字段全部更新一遍，无论该字段是否被修改#删models.User.objects.filter(id=delete_id).delete() django orm中如何创建表关系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&quot;&quot;&quot;表与表之间的关系 一对多 多对多 一对一 没有关系判断表关系的方法:换位思考若1个a对应多个b，1个b对应1个a，那么a和b就是1对多，且多的一方是b若1个a对应多个b，1个b对应多个a，那么a和b就是多对多若1个a对应1个b，1个b对应1个a，那么a和b就是1对1&quot;&quot;&quot;图书表出版社表作者表作者详情表&quot;&quot;&quot;图书和出版社是一对多的关系 外键字段建在多的那一方 book图书和作者是多对多的关系 需要创建第三张表来专门存储作者与作者详情表是一对一&quot;&quot;&quot;models.py的代码如下from django.db import models# 创建表关系 先将基表创建出来 然后再添加外键字段class Book(models.Model): title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8,decimal_places=2)# 总共八位 小数点后面占两位 &quot;&quot;&quot; 图书和出版社是一对多 并且书是多的一方 所以外键字段放在书表里面 &quot;&quot;&quot; publish = models.ForeignKey(to=&#x27;Publish&#x27;) # 默认就是与出版社表的主键字段做外键关联 &quot;&quot;&quot; 如果字段对应的是ForeignKey 那么会orm会自动在字段的后面加_id 如果你加了_id那么orm还是会在后面继续加_id，变成name_id_id了，所以在定义ForeignKey的时候就不要自己加_id &quot;&quot;&quot; &quot;&quot;&quot; 图书和作者是多对多的关系 外键字段建在任意一方均可 但是推荐你建在查询频率较高的一方 &quot;&quot;&quot; authors = models.ManyToManyField(to=&#x27;Author&#x27;) &quot;&quot;&quot; authors是一个虚拟字段 主要是用来告诉orm 书籍表和作者表是多对多关系 让orm自动帮你创建第三张关系表 &quot;&quot;&quot;class Publish(models.Model): name = models.CharField(max_length=32) addr = models.CharField(max_length=32)class Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() &quot;&quot;&quot; 作者与作者详情是一对一的关系 外键字段建在任意一方都可以 但是推荐你建在查询频率较高的表中 &quot;&quot;&quot; author_detail = models.OneToOneField(to=&#x27;AuthorDetail&#x27;) &quot;&quot;&quot; OneToOneField也会自动给字段加_id后缀 &quot;&quot;&quot;class AuthorDetail(models.Model): phone = models.BigIntegerField() # 或者直接字符类型 addr = models.CharField(max_length=32)&quot;&quot;&quot; orm中如何定义三种关系 publish = models.ForeignKey(to=&#x27;Publish&#x27;) # 默认就是与出版社表的主键字段做外键关联 authors = models.ManyToManyField(to=&#x27;Author&#x27;) author_detail = models.OneToOneField(to=&#x27;AuthorDetail&#x27;) ForeignKey、OneToOneField会自动在字段后面加_id后缀&quot;&quot;&quot;# 在django1.X版本中外键默认都是级联更新删除的","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"django","slug":"code/python/django","permalink":"http://example.com/categories/code/python/django/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Django项目的搭建和配置","slug":"Django项目的搭建","date":"2023-02-05T07:46:17.205Z","updated":"2023-02-06T09:23:43.056Z","comments":true,"path":"2023/02/05/Django项目的搭建/","link":"","permalink":"http://example.com/2023/02/05/Django%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Django创建项目 创建应用：pycharm的terminal中运行start manage.py start app01 以下操作都是在项目名文件夹下的settings.py操作的 注册应用： 123456789INSTALLED_APPS = [ &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;app01&#x27;, # INSTALLED_APPS列表里加上&#x27;app01&#x27;] 写入templates路径： 1234567TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)], &#125;如果报错：Templates doesn&#x27;t exist. 那么可能是因为settings里面的Templates里的DIRS列表里没有写入template的路径 连接数据库配置 1234567891011DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, &#x27;PORT&#x27;: 3306, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: 123, &#x27;NAME&#x27;: &#x27;bbs&#x27;, &#x27;CHARSET&#x27;: &#x27;utf8&#x27; &#125;&#125; 设置静态文件读取路径，方便使用bootsrap和其他组件样式： 123STATICFILES_DIRS = [ os.path.join(BASE_DIR, &#x27;static&#x27;)] 在app下的随便一个init文件配置数据库： 12import pymysqlpymysql.install_as_MySQLdb() Django文件介绍1234567891011121314-mysite项目文件夹 --mysite文件夹 --settings.py 配置文件 --urls.py 路由与视图函数对应关系(路由层) --wsgi.py wsgiref模块(一般不考虑) --manage.py django的入口文件 --db.sqlite3 django自带的sqlite3数据库(小型数据库 功能不是很多还有bug) --app01文件夹 --admin.py django后台管理 --apps.py 注册使用 --migrations文件夹 数据库迁移记录 --models.py 数据库相关的 模型类(orm) --tests.py 测试文件 --views.py 视图函数(视图层) django小白必会三板斧123456789101112&quot;&quot;&quot;HttpResponse 返回字符串类型的数据render 返回html文件的redirect 重定向，想指定的url发送请求的 return redirect(&#x27;https://www.mzitu.com/&#x27;) return redirect(&#x27;/home/&#x27;)&quot;&quot;&quot; 静态文件配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455我们将html文件默认都放在templates文件夹下我们将网站所使用的静态文件默认都放在static文件夹下静态文件 js文件 css文件 网站用到的图片文件 第三方前端框架 ... 拿来就可以直接使用的文件 # django默认是不会自动帮你创建static文件夹 需要你自己手动创建一般情况下我们在static文件夹内还会做进一步的划分处理 -static --js --css --img 其他第三方文件# 静态文件配置在配置文件settings里面STATIC_URL = &#x27;/static/&#x27; # 类似于访问静态文件的令牌如果你想要访问静态文件 你就必须以static开头，比如/static/bootstrap-3.3.7-dist/js/bootstrap.min.js有了/static/令牌，才能从列表里面的路径从上往下依次查找指定文件 bootstrap-3.3.7-dist/js/bootstrap.min.js 列表里面的路径都没有指定文件才会报错&quot;&quot;&quot;# 静态文件配置STATICFILES_DIRS = [ os.path.join(BASE_DIR,&#x27;static&#x27;), 因为bootstrap相关文件在static里，所以可以被访问到 os.path.join(BASE_DIR,&#x27;static1&#x27;), os.path.join(BASE_DIR,&#x27;static2&#x27;),]&quot;&quot;&quot;# 静态文件动态解析，通过下列代码引入文件，即使令牌改了也不会影响文件的导入 &#123;% load static %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/css/bootstrap.min.css&#x27; %&#125;&quot;&gt; &lt;script src=&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/js/bootstrap.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt;# 在前期我们使用django提交post请求的时候，如果不采用csrf认证，需要取配置文件中注释掉一行代码MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;django.middleware.common.CommonMiddleware&#x27;, # &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, 注释掉这一行 &#x27; django.contrib.auth.middleware.AuthenticationMiddleware&#x27;, &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,]","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"django","slug":"code/python/django","permalink":"http://example.com/categories/code/python/django/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"环境变量的配置和作用","slug":"环境变量的配置和作用","date":"2023-02-05T07:02:40.643Z","updated":"2023-02-05T07:02:40.760Z","comments":true,"path":"2023/02/05/环境变量的配置和作用/","link":"","permalink":"http://example.com/2023/02/05/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%9C%E7%94%A8/","excerpt":"","text":"环境变量的作用：Windows中如果你要在命令行中执行某个文件，那么系统会先在目前所在的文件夹中检索看这个文件在不在，在的话就执行；不在的话就在Windows的环境变量(是一个存放着各种文件夹路径的列表)中存放的文件夹下去检索目标文件，找到就执行，还找不到就说找不到了。 重复文件名问题：系统在环境变量存放的文件夹中检索文件时，会按照列表中从上到下的顺序检索文件夹，所以如果2个文件夹里有同名文件，那么系统只会找到存放在上面的那个文件夹的文件执行。解决方案是：各复制一份这个重复名字的文件的副本，再分别进行重命名(直接改名字而不复制可能会受到限制不给重命名) 环境变量的设置：我的电脑-》属性-》高级系统设置-》环境变量-》添加新的文件夹路径(比如C:\\)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"windows","slug":"code/windows","permalink":"http://example.com/categories/code/windows/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Python内置函数","slug":"Python内置函数","date":"2023-02-05T06:58:05.812Z","updated":"2023-02-05T06:58:05.925Z","comments":true,"path":"2023/02/05/Python内置函数/","link":"","permalink":"http://example.com/2023/02/05/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","excerpt":"","text":"enumerate枚举123456789# enumerate枚举test_list = [1, 3, 5, 7, 9]for i, j in enumerate(test_list): print(i, j, sep=&#x27;\\t&#x27;) # i对应索引，j对应列表的内容。即可以取到索引和内容0 11 32 53 74 9 eval执行字符串中的表达式1234x = eval(&#x27;&#123;1, 3, 4&#125;&#x27;)print(type(x)) #dictprint(eval(&#x27;1+9&#x27;)) #10eval(&#x27;print(&quot;hahaha&quot;)&#x27;) #hahaha isinstance(obj, cls)判断obj是不是cls的实例12print(isinstance([1,2], list))print(isinstance([1,2], set)) zip(x, y)123456789101112131415#zip(x, y)拉链函数，将x，y索引相同的两个值组成一个元组，返回这些元组的列表x = [1, 2, 3, 4]y = (11, 22, 33, 44)print(type(zip(x, y)))#&lt;class &#x27;zip&#x27;&gt;for i, j in zip(x, y): #这里的i，j是自动解包的结果 print(i, j, sep=&#x27;\\t&#x27;)t = list(zip(x, y))print(t)&lt;class &#x27;zip&#x27;&gt;1 112 223 334 44[(1, 11), (2, 22), (3, 33), (4, 44)] 进制转换123bin(111)oct(111)hex(111) ascii字符12chr(65)ord(&#x27;a&#x27;)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Python常用模块","slug":"Python常用模块","date":"2023-02-05T06:57:20.051Z","updated":"2023-02-05T06:57:20.158Z","comments":true,"path":"2023/02/05/Python常用模块/","link":"","permalink":"http://example.com/2023/02/05/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/","excerpt":"","text":"hashlib123456import hashlibm=hashlib.md5()m.update(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;))m.update(&#x27;world&#x27;.encode(&#x27;utf-8&#x27;))res=m.hexdigest() # &#x27;helloworld&#x27;的加密字符串 序列化模块(Json pickle)123456789101112131415161718序列化得到结果=&gt;特定的格式的内容 有两种用途1、可用于存储=》用于存档 采用一种专用的格式=》pickle只有python可以识别2、传输给其他平台使用=》跨平台数据交互 采用一种通用、能够被所有语言识别的格式=》json# 序列化json_res=json.dumps([1,&#x27;aaa&#x27;,True,False])print(json_res,type(json_res)) # &quot;[1, &quot;aaa&quot;, true, false]&quot;， str# 反序列化l=json.loads(json_res)将序列化的结果写入文件的简单方法with open(&#x27;test.json&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f: json.dump([1,&#x27;aaa&#x27;,True,False],f) # 普通的dumps方法去掉s而已 res = pickle.dumps([1.2, True, &#x27;acv&#x27;, [11, 2]])#pickle序列化后的类型是byteres2 = pickle.loads(res)with open(&#x27;test.pickle&#x27;, &#x27;rb&#x27;) as f: res = pickle.load(f) os123456789# 获取某一个文件夹下所有的子文件以及子文件夹的名字,只找最外面的1层# res=os.listdir(&#x27;.&#x27;)# os.remove() 删除一个文件# os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录os.path.isfile(r&#x27;aaa&#x27;)os.path.isdir(r&#x27;aaa&#x27;)os.path.join(&#x27;a&#x27;,&#x27;/&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)os.path.dirname(path) #获取path的目录路径__file__ #获取当前文件的绝对路径 random模块1234567random.random() #(0,1)----floatrandom.uniform(1, 3) # (1, 3)的小数random.randint(1, 3) # [1,3]random.randrange(1, 3) # [1,3)的整数random.choice([111, &#x27;aaa&#x27;, [4, 5]]) #列表中的三个元素取一个random.seed(10) #在每次用到随机值时可以通过设定seed来指定随机数 sys模块12345命令行中敲：python3.8 run.py 1 2 3 即运行当前目录下的run.py文件，传如参数1 2 3# sys.argv获取的是命令行中解释器后参数值sys.argv的值为[1, 2, 3]这个命令通常在用命令行调用python程序中使用 time模块123456789101112131415161718192021222324252627# 时间分为三种格式：# 1、时间戳：从1970年到现在经过的秒数# 作用：用于时间间隔的计算# print(time.time())# 2、按照某种格式显示的时间：2020-03-30 11:11:11# 作用：用于展示时间# print(time.strftime(&#x27;%Y-%m-%d %H:%M:%S %p&#x27;))# print(time.strftime(&#x27;%Y-%m-%d %X&#x27;))# 3、结构化的时间# 作用：用于单独获取时间的某一部分# res=time.localtime()# print(res) #time.struct_time(tm_year=2023, tm_mon=1, tm_mday=29, tm_hour=10, tm_min=47, tm_sec=45, tm_wday=6, tm_yday=29, tm_isdst=0)# print(res.tm_year)!!!真正需要掌握的只有一条：format string&lt;------&gt;timestamp&#x27;1988-03-03 11:11:11&#x27;+7format string---&gt;struct_time---&gt;timestampstruct_time=time.strptime(&#x27;1988-03-03 11:11:11&#x27;,&#x27;%Y-%m-%d %H:%M:%S&#x27;)timestamp=time.mktime(struct_time)+7*86400 # 时间戳加7天，可用于会员过期时间print(timestamp)format string&lt;---struct_time&lt;---timestampres=time.strftime(&#x27;%Y-%m-%d %X&#x27;,time.localtime(timestamp))print(res)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"包和模块的导入","slug":"包和模块的导入","date":"2023-02-05T06:56:03.637Z","updated":"2023-02-05T06:56:03.745Z","comments":true,"path":"2023/02/05/包和模块的导入/","link":"","permalink":"http://example.com/2023/02/05/%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AF%BC%E5%85%A5/","excerpt":"","text":"包的导入12345678910111213141516171819202122232425262728293031323334&#x27;&#x27;&#x27;1、包就是一个包含有__init__.py文件的文件夹2、为何要有包 包的本质是模块的一种形式，包是用来被当做模块导入&#x27;&#x27;&#x27;导入包实际的运行情况#1、产生一个名称空间#2、运行包下的__init__.py文件（如果导入的是模块就是运行模块名.py文件），将运行过程中产生的名字都丢到1的名称空间中#3、在当前执行文件的名称空间中拿到一个名字‘模块名’，‘模块名’指向1的名称空间# from mmm import x# 环境变量是以执行文件为基准的，所有的被导入的模块或者说后续的其他文件引用的sys.path都是参照执行文件的sys.path，即path的第一个元素都是执行文件所在的文件夹的路径# 强调：# 1.关于包相关的导入语句也分为import和from ... import ...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：# 凡是在导入时带点的，点的左边都必须是一个包，否则非法。# 可以带有一连串的点，如import 顶级包.子包.子模块,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。# 例如：# from a.b.c.d.e.f import xxx# import a.b.c.d.e.f# 其中a、b、c、d、e 都必须是包# 2、包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间## 3、import导入文件时，产生名称空间中的名字来源于文件，# import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件相对导入：.表示当前文件所在文件夹。..表示上一层文件夹。相对导入一般用于包内模块的相互引用from .mm import f1表示导入位于当前文件所在文件夹的mm.py中的函数f1 模块操作(包的操作同理)： 导入模块： a) 全部导入：import moduleName b) 从模块种导入指定函数：from module impore func1(,func2….) Python在查找模块导入时，遵循以下查找顺序： a) 先查找内存中已经加载好的模块 b) 再查找python的内置模块 c) 最后查找sys.path路径中包含的模块 对system..path的操作： a) sys.path是一个列表，它的第一个路径是当前执行文件所在的文件夹 b) 如果要将不存在于该文件夹的模块导入，要将该模块的路径添加到system.path。 如将func3导入文件： import sys sys.path.append(“func3的路径比如桌面：C:\\Users\\Desktop”)#导入后，python会在你导入func3时在该路径下查找func3的文件 import func3","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Python魔法方法","slug":"Python魔法方法","date":"2023-02-05T06:54:31.563Z","updated":"2023-02-05T06:54:31.673Z","comments":true,"path":"2023/02/05/Python魔法方法/","link":"","permalink":"http://example.com/2023/02/05/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/","excerpt":"","text":"魔法方法 魔法方法就是满足了特定条件会自动触发的方法 12345678# __init__：类实例化会触发# __str__:打印对象会触发# __call__:对象()触发类的__call__()。让对象可以像函数一样被调用。类也是对象，类(),类的实例化过程调用元类的__call__。# __new__:在类实例化会触发，它比__init__早,创造对象用的，有点复杂# __del__:del 对象，对象回收的时候触发# __setattr__,__getattr__:(.拦截方法)，当对象.属性触发--&gt;赋值会调用setattr，取值只有引发AttributeError才会调用getattr# __getitem__,__setitem__:([]拦截)，当对象[属性]触发--&gt;赋值会调用setitem，取值会调用getitem# __enter__和__exit__ 上下文管理器 setattr，getattr，setitem，getitem演示1234567891011121314# class Person:# def __init__(self,name):# self.name=name# def __setitem__(self, key, value):# setattr(self,key,value) #反射# def __getitem__(self, item):# return getattr(self,item) # 反射取值## p=Person(&#x27;czw&#x27;)# # p.name=&#x27;ppp&#x27;# p[&#x27;name&#x27;]=10 # 如何实现 重写__setitem__魔法方法# # print(p.name)## print(p[&#x27;name&#x27;]) _eq_12345678910111213141516171819class A: def __init__(self,x,y): self.x = x self.y = y def __eq__(self,obj): # 打印出比较的第二个对象的x值 print(obj.x) if self.x +self.y == obj.x+obj.y: return True else: return Falsea=A(1,2)b=A(99,3)print(a==b)print(a==&#x27;ddd&#x27;) # 当执行==s时，会触发__eq__的执行，并且把b传进去，就是object# ==后只要是对象，就可以传进去，就是object","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"字符编码","slug":"编码","date":"2023-02-05T06:50:43.850Z","updated":"2023-02-05T06:52:05.123Z","comments":true,"path":"2023/02/05/编码/","link":"","permalink":"http://example.com/2023/02/05/%E7%BC%96%E7%A0%81/","excerpt":"","text":"字符编码 ascii码是一开始美国采用的编码，只有1个字节的大小，表示256种字符，为字母和标点符号 gbk是中文编码 unicode是万国码，但它只做了字符和数字的对应关系，而没有规定存储方式，utf-8就是unicode编码的一种存储方式，即可变长的存储，简单字符用少字节，复杂字符用多字节存储 编码和解码123456789101112131415编码和解码是str和bytes之间的转换bytes.decode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;) Return the bytes decoded to a str.str.encode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;) Return the string encoded to bytes.a = &#x27;上&#x27;# python默认用unicode编码b = a.encode(&#x27;utf-8&#x27;) #用utf-8的编码方式： utf-8的str ==&gt; byteprint(b, type(b))c = b.decode(&#x27;utf-8&#x27;) #用utf-8的解码方式： byte ==&gt; utf-8的strprint(c, type(c))# b&#x27;\\xe4\\xb8\\x8a&#x27; &lt;class &#x27;bytes&#x27;&gt;# 上 &lt;class &#x27;str&#x27;&gt;","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"深浅拷贝","slug":"深浅拷贝","date":"2023-02-05T06:32:01.099Z","updated":"2023-02-05T06:48:55.610Z","comments":true,"path":"2023/02/05/深浅拷贝/","link":"","permalink":"http://example.com/2023/02/05/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"python不同类型的变量为何可以互相赋值python的一切变量都是指着一个地址，由于地址(也可理解为指针)的大小和类型(都是无符号整数)都是一样的，所以不同类型的变量可以相互赋值，本质上就是地址之间的赋值。 浅拷贝浅拷贝就是复制一份原来地址指向的第一块空间，并给一个新地址指向那份空间的副本，把新地址赋值给新变量。由于浅拷贝只是复制了地址指向的第一块空间，所以如果这个空间存的是不可变对象，那就是真正地拷贝了(即修改不会影响原变量的内容)；但如果存的是可变对象的引用，那么改变了这个对象的内容会影响到原变量的内容的 如果浅拷贝的内容是不可变类型，那么新变量指向的地址和原变量是一样的，因为不可变类型是常量，在系统中只要存一份就可以了。如果是可变类型，就会申请一个新地址，指向原变量的顶层引用的副本 函数传参就是传一个浅拷贝过去 深拷贝深拷贝是递归拷贝，就是申请一个新地址，并把原变量的所有内容都拷贝一份","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Python文件操作","slug":"文件操作","date":"2023-02-05T06:28:21.074Z","updated":"2023-02-05T06:48:46.605Z","comments":true,"path":"2023/02/05/文件操作/","link":"","permalink":"http://example.com/2023/02/05/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"编码和解码123456789101112131415编码和解码是str和bytes之间的转换bytes.decode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;) Return the bytes decoded to a str.str.encode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;) Return the string encoded to bytes.a = &#x27;上&#x27;# python默认用unicode编码b = a.encode(&#x27;utf-8&#x27;) #用utf-8的编码方式： utf-8的str ==&gt; byteprint(b, type(b))c = b.decode(&#x27;utf-8&#x27;) #用utf-8的解码方式： byte ==&gt; utf-8的strprint(c, type(c))# b&#x27;\\xe4\\xb8\\x8a&#x27; &lt;class &#x27;bytes&#x27;&gt;# 上 &lt;class &#x27;str&#x27;&gt; 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344路径问题：# 解决方案一：推荐。用Python的raw字符串避免所有转义# open(r&#x27;C:\\a.txt\\nb\\c\\d.txt&#x27;)# 解决方案二：用/代替\\# open(&#x27;C:/a.txt/nb/c/d.txt&#x27;)with上下文管理，可以自动在最后执行f.close()关闭文件with open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;) as f1,\\ #用\\来完成一条语句的换行 open(&#x27;b.txt&#x27;,mode=&#x27;rt&#x27;) as f2: 指定字符编码强调：t和b不能单独使用，必须跟r/w/a连用t文本（默认的模式） 1、读写都以str（unicode）为单位的 2、文本文件 3、必须指定encoding=&#x27;utf-8&#x27;# 没有指定encoding参数操作系统会使用自己默认的编码# linux系统默认utf-8# windows系统默认gbkwith open(&#x27;c.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f: 模式详解1、r（默认的操作模式）：只读模式，当文件不存在时报错，当文件存在时文件指针跳到开始位置2、w：只写模式，当文件不存在时会创建空文件，当文件存在会清空文件，指针位于开始位置 2.1、在以w模式打开文件没有关闭的情况下，连续写入，新的内容总是跟在旧的之后 2.2、如果重新以w模式打开文件，则会清空文件内容3、a：只追加写，在文件不存在时会创建空文件，在文件存在时文件指针会直接调到末尾t与b模式的区别：1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节(内部帮我们编码和解码)，b模式则需要手动编码与解码，所以此时t模式更为方便2、针对非文本文件（如图片、视频、音频等）只能使用b模式在读取文件时，为防止文件过大导致内存不够，通常用for循环读取with open(r&#x27;&#123;&#125;&#x27;.format(src_file),mode=&#x27;rb&#x27;) as f1,\\ open(r&#x27;&#123;&#125;&#x27;.format(dst_file),mode=&#x27;wb&#x27;) as f2: for line in f1: f2.write(line) 文本转二进制看《编码和解码》模块","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"数据类型","slug":"数据类型","date":"2023-02-05T06:16:07.882Z","updated":"2023-02-05T06:48:51.118Z","comments":true,"path":"2023/02/05/数据类型/","link":"","permalink":"http://example.com/2023/02/05/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"字符串格式化输出12345678910111213141516171819202122232425262728293031323334353637str.format:兼容性好# 按照位置传值# res=&#x27;我的名字是 &#123;&#125; 我的年龄是 &#123;&#125;&#x27;.format(&#x27;czw&#x27;,18)# res=&#x27;我的名字是 &#123;0&#125;&#123;0&#125;&#123;0&#125; 我的年龄是 &#123;1&#125;&#123;1&#125;&#x27;.format(&#x27;czw&#x27;,18)# 打破位置的限制，按照key=value传值# res=&quot;我的名字是 &#123;name&#125; 我的年龄是 &#123;age&#125;&quot;.format(age=18,name=&#x27;czw&#x27;)填充与格式化!!先取到值,然后在冒号后设定填充格式：[填充字符][对齐方式][宽度]!!# *&lt;10：左对齐，总共10个字符，不够的用*号填充print(&#x27;&#123;0:*&lt;10&#125;&#x27;.format(&#x27;开始执行&#x27;)) # 开始执行******# *&gt;10：右对齐，总共10个字符，不够的用*号填充print(&#x27;&#123;0:*&gt;10&#125;&#x27;.format(&#x27;开始执行&#x27;)) # ******开始执行# *^10：居中显示，总共10个字符，不够的用*号填充print(&#x27;&#123;0:*^10&#125;&#x27;.format(&#x27;开始执行&#x27;)) # ***开始执行***精度与进制print(&#x27;&#123;salary:.3f&#125;&#x27;.format(salary=1232132.12351)) #精确到小数点后3位，四舍五入，结果为：1232132.124print(&#x27;&#123;0:b&#125;&#x27;.format(123)) # 转成二进制，结果为：1111011print(&#x27;&#123;0:o&#125;&#x27;.format(9)) # 转成八进制，结果为：11print(&#x27;&#123;0:x&#125;&#x27;.format(15)) # 转成十六进制，结果为：fprint(&#x27;&#123;0:,&#125;&#x27;.format(99812939393931)) # 千分位格式化，结果为：99,812,939,393,931# 2.3 f:python3.5以后才推出x = input(&#x27;your name: &#x27;)y = input(&#x27;your age: &#x27;)res = f&#x27;我的名字是&#123;x&#125; 我的年龄是&#123;y&#125;&#x27;# raw字符串：取消所有的转义r&#x27;\\n&#x27;表示2个字符&#x27;\\&#x27;和&#x27;n&#x27;,而不是换行 r&#x27;&#123;&#125;&#x27;.format(src_file) #raw只针对转义，不针对&#123;&#125;，format方法还是可以使用的 常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990按索引取值(正向取+反向取) ：只能取，不能改，因为str是常量msg=&#x27;hello world&#x27;# 正向取# print(msg[0])# 反向取# print(msg[-1])#切片.相当于浅拷贝copy，只拷贝顶层引用# res=msg[0:5]# 步长msg = &#x27;hello world&#x27;# res=msg[0:5:2] # 0 2 4# 反向步长# res=msg[5:0:-1] #5 4 3 2 1# print(res) #&quot; olle&quot;移除字符串左右两侧的符号strip、lstrip、rstrip# 默认去掉的空格# msg=&#x27; czw &#x27;# res=msg.strip()# print(msg) # 不会改变原值# print(res) # 是产生了新值# 可指定移除的字符# msg=&#x27;****czw****&#x27;# print(msg.strip(&#x27;*&#x27;))切分split：把一个字符串按照某种分隔符进行切分，得到一个列表。rsplit# # 默认分隔符是空格# info=&#x27;czw 18 male&#x27;# res=info.split()# # 指定分隔符# info=&#x27;czw:18:male&#x27;# res=info.split(&#x27;:&#x27;)# 指定分隔次数(了解)# info=&#x27;czw:18:male&#x27;# res=info.split(&#x27;:&#x27;,1)lower,upper# msg=&#x27;AbbbCCCC&#x27;# print(msg.lower())# print(msg.upper())startswith,endswith# print(&quot;alex is sb&quot;.startswith(&quot;alex&quot;))# print(&quot;alex is sb&quot;.endswith(&#x27;sb&#x27;))join: 把可迭代对象里的字符串元素拼接成字符串# l=[&#x27;czw&#x27;, &#x27;18&#x27;, &#x27;male&#x27;]# res=&quot;:&quot;.join(l) # 按照某个分隔符号，把元素全为字符串的列表拼接成一个大字符串replace# msg=&quot;you can you up no can no bb&quot;# print(msg.replace(&quot;you&quot;,&quot;YOU&quot;,))# print(msg.replace(&quot;you&quot;,&quot;YOU&quot;,1))isdigit# 判断字符串是否由整数组成# print(&#x27;123&#x27;.isdigit()) True# print(&#x27;12.3&#x27;.isdigit()) Falsefind,rfind,index,rindexmsg=&#x27;hello czw hahaha&#x27;# 找到返回起始索引# print(msg.find(&#x27;e&#x27;)) # 返回要查找的字符串在大字符串中的起始索引# print(msg.find(&#x27;czw&#x27;))# print(msg.index(&#x27;e&#x27;))# print(msg.index(&#x27;czw&#x27;))# 找不到# print(msg.find(&#x27;xxx&#x27;)) # 返回-1，代表找不到# print(msg.index(&#x27;xxx&#x27;)) # 抛出异常count# msg=&#x27;hello czw hahaha czw、 czw&#x27;# print(msg.count(&#x27;czw&#x27;))is系列# print(&#x27;abc&#x27;.islower())# print(&#x27;ABC&#x27;.isupper())# print(&#x27;123123aadsf&#x27;.isalnum()) # 字符串由字母或数字组成结果为True# print(&#x27;ad&#x27;.isalpha()) # 字符串由由字母组成结果为True# print(&#x27; &#x27;.isspace()) # 字符串由空格组成结果为True 列表常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950追加# l=[111,&#x27;czw&#x27;,&#x27;hello&#x27;]# l.append(3333)# l.append(4444)# print(l)插入值# l=[111,&#x27;czw&#x27;,&#x27;hello&#x27;]# l.insert(0,&#x27;alex&#x27;)# print(l)extend拓展列表# new_l=[1,2,3]# l=[111,&#x27;czw&#x27;,&#x27;hello&#x27;]# l.extend(new_l)# print(l) [111, &#x27;czw&#x27;, &#x27;hello&#x27;, 1, 2, 3]删除# 方式一：通用的删除方法，只是单纯的删除、没有返回值# l = [111, &#x27;czw&#x27;, &#x27;hello&#x27;]# del l[1]# 方式二：l.pop()根据索引删除，会返回删除的值# l = [111, &#x27;czw&#x27;, &#x27;hello&#x27;]# l.pop() # 不指定索引默认删除最后一个# print(l)# 方式三：l.remove()根据元素删除，返回None# l = [111, &#x27;czw&#x27;, [1,2,3],&#x27;hello&#x27;]# l.remove([1,2,3])需要掌握操作l = [1, &#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;aaa&#x27;,&#x27;aaa&#x27;]#l.count(&#x27;aaa&#x27;)# print(l.index(&#x27;aaa&#x27;))# print(l.index(&#x27;aaaaaaaaa&#x27;)) # 找不到报错# l.clear()# l.reverse():不是排序，就是将列表倒过来# l.sort(): 列表内元素必须是同种类型才可以排序# l=[11,-3,9,2,3.1]# l.sort() # 默认从小到大排，称之为升序# l.sort(reverse=True) # 从大到小排，设置为降序 元组常用方法1234567按照索引/位置存放多个值，只用于读不用于改。如果元组中只有一个元素，必须加逗号索引取值t.index(ele)# 获得指定元素的索引t.count(ele)# 获得指定元素在元组中的个数 字典常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748value可以是任意类型，但是key必须是不可变类型,且不能重复造字典的方式一：# d=&#123;&#x27;k1&#x27;:111, (1,2,3):222&#125;造字典的方式二：# d=dict(x=1,y=2,z=3)造字典的方式三：# info=[# [&#x27;name&#x27;,&#x27;czw&#x27;],# (&#x27;age&#x27;,18),# [&#x27;gender&#x27;,&#x27;male&#x27;]# ]# res=dict(info)按key存取值：可存可取# d=&#123;&#x27;k1&#x27;:111&#125;# 针对赋值操作：key存在，则修改# d[&#x27;k1&#x27;]=222# 针对赋值操作：key不存在，则创建新值# d[&#x27;k2&#x27;]=3333成员运算in和not in:根据key# d=&#123;&#x27;k1&#x27;:111,&#x27;k2&#x27;:2222&#125;# print(&#x27;k1&#x27; in d)# print(111 in d)#4、删除d=&#123;&#x27;k1&#x27;:111,&#x27;k2&#x27;:2222&#125;# 4.1 通用删除# del d[&#x27;k1&#x27;]# 4.2 pop删除：根据key删除元素，返回删除key对应的那个value值# res=d.pop(&#x27;k2&#x27;)# 4.3 popitem删除：随机删除，返回元组(删除的key,删除的value)# res=d.popitem()键keys()，值values()，键值对items()d=&#123;&#x27;k1&#x27;:111&#125;#1、d.clear()#2、d.update()：根据参数扩展字典，如果原字典无则添加；如原字典有，若一样则不变，不一样则修改d.update(&#123;&#x27;k2&#x27;:222,&#x27;k3&#x27;:333&#125;) #&#123;&#x27;k1&#x27;: 111, &#x27;k2&#x27;: 222, &#x27;k3&#x27;: 333&#125;print(d)#3、d.get() ：根据key取值，容错性好# print(d[&#x27;k2&#x27;]) # key不存在则报错 集合常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960在&#123;&#125;内用逗号分隔开多个元素，多个元素满足以下三个条件# 1. 集合内元素必须为不可变类型# 2. 集合内元素无序# 3. 集合内元素没有重复# 4.1 取交集：两者共同的好友# res=friends1 &amp; friends2# print(res)# print(friends1.intersection(friends2))# 4.2 取并集/合集：两者所有的好友# print(friends1 | friends2)# print(friends1.union(friends2))# 4.3 取差集：取friends1独有的好友# print(friends1 - friends2)# print(friends1.difference(friends2))# 取friends2独有的好友# print(friends2 - friends1)# print(friends2.difference(friends1))# 4.4 对称差集: 求两个用户独有的好友们（即去掉共有的好友）# print(friends1 ^ friends2)# print(friends1.symmetric_difference(friends2))# 4.5 父子集：包含的关系# s1=&#123;1,2,3&#125;# s2=&#123;1,2,4&#125;# 不存在包含关系，下面比较均为False# print(s1 &gt; s2)# print(s1 &lt; s2)# s1=&#123;1,2,3&#125;# s2=&#123;1,2&#125;# print(s1 &gt; s2) # 当s1大于或等于s2时，才能说是s1是s2他爹# =========================去重=========================# 1、只能针对不可变类型去重,即可迭代对象中的元素为不可变类型# print(set([1,1,1,1,2])) ==》｛1,2｝# print(set([[1, ],1,1,1,2])) ==》error,因为[1, ]不是不可变类型# 2、无法保证原来的顺序# l=[1,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;z&#x27;,1,1,1,2]# l=list(set(l))# 需要掌握的内置方法1：discard# s.discard(4) # 删除元素不存在do nothing# s.remove(4) # 删除元素不存在则报错# 需要掌握的内置方法2：update：与字典的update的用法一致# s.update(&#123;1,3,5&#125;)# 需要掌握的内置方法3：pop：随机弹出一个值，返回弹出的值# res=s.pop()# 需要掌握的内置方法4：add：添加一个值# s.add(4)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python杂记","slug":"python基础","date":"2023-02-05T06:07:16.750Z","updated":"2023-02-05T07:06:46.755Z","comments":true,"path":"2023/02/05/python基础/","link":"","permalink":"http://example.com/2023/02/05/python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"类 类中属性查找的顺序：对象&#x3D;&gt;类&#x3D;&gt;父类 闭包函数闭包函数时一种广泛的叫法，存在于所有的编程语言中，只要符合以下2点就是闭包函数： 闭包函数定义在其他函数的内部 闭包函数对外部作用域有引用 123456789101112131415161718装饰器就是闭包函数的一个典型应用：def wrapper(func): def inner(*args, **kwargs): # code res = func(*args, **kwargs) # code return res return innerdef a(): print(hello)a = wrapper(a)# 把b当作参数传入wrapper，并把返回值赋给b@wrapperdef b(): print(hello) pymysql的使用1234567891011121314151617181920212223242526import pymysql#连接数据库conn=pymysql.connect(host=&#x27;101.133.225.166&#x27;, user=&#x27;root&#x27;, password=&quot;123456&quot;,database=&#x27;test&#x27;, port=3306)# 获取游标cursor=conn.cursor(cursor=pymysql.cursors.DictCursor) # 查出来数据是字典格式# 操作 定义一个sql# sql=&#x27;select id,name from book&#x27;# cursor.execute(sql)# ret=cursor.fetchall()# print(ret)# 插入# sql=&#x27;insert into book(id,name) values (%s,%s)&#x27;# cursor.execute(sql,[3,&#x27;lqz&#x27;])# conn.commit()# 删除# sql=&#x27;delete from book where name=%s&#x27;# cursor.execute(sql,[&#x27;lqz&#x27;])# conn.commit()# 更新# sql=&#x27;update book set name=%s where id=%s&#x27;# cursor.execute(sql,[&#x27;xxx&#x27;,1])# conn.commit() 字典传参1**dict传值，可以等同于**kwargs，将字典打散按关键字传值 小技巧lambda表达式匿名函数lambda用于临时调用一次的场景：更多的是将匿名函数与其他函数配合使用 lambda 参数: 返回值 12345678910111213141516171819202122232425应用场景：某些函数里需要一些经过简单处理后的数据，那么这个简单处理的过程就可以用lambda更为简便地实现。比如max(iterable, *, key=None)函数中，key实参指定排序函数用的参数。返回可迭代对象中最大的元素salaries=&#123; &#x27;siry&#x27;:3000, &#x27;tom&#x27;:7000, &#x27;lili&#x27;:10000, &#x27;jack&#x27;:2000&#125;# 迭代出的内容 比较的值# &#x27;siry&#x27; 3000# &#x27;tom&#x27; 7000# &#x27;lili&#x27; 10000# &#x27;jack&#x27; 2000问题就是key默认是迭代出的内容，但我们希望key是salaries[迭代出的内容]，即薪水的资料，这时就可以用lambda简单的处理一下# def func(k):# return salaries[k]# res=max(salaries,key=func) # 返回值=func(&#x27;siry&#x27;) #这是key需要的就是salaries[迭代的内容]这样处理过的数据。这里func会自动以迭代出的内容作为参数执行，再把返回值赋给key# res=max(salaries,key=lambda k:salaries[k]) 这时lambda等同于func，但明显func还要单独定义啥的，比较复杂，不如lambda简单。这里的k默认就是迭代出的内容。注意，这里返回的res是满足条件的可迭代对象，而不是最大的比较的值还可应用于列表排序：a = [(1, 2), (4, 1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1]) 三元表达式12expression1 if condition else expression2x = 1 if 1 &gt; 3 else 3 生成式1234567891011121、列表推导式 [i*2 for i in [1, 2]]2、字典生成式# items=[(&#x27;name&#x27;,&#x27;egon&#x27;),(&#x27;age&#x27;,18),(&#x27;gender&#x27;,&#x27;male&#x27;)]# res=&#123;k:v for k,v in items if k != &#x27;gender&#x27;&#125;3、集合生成式# keys=[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;gender&#x27;]# set1=&#123;key for key in keys&#125;4、生成器表达式# g=(i for i in range(10) if i &gt; 3) yield解析12345678910111213141516171819202122232425262728293031323334353637383940&#x27;&#x27;&#x27;yield函数解析：yield出现在函数中会使函数的调用结果变为一个生成器.这样的函数可以暂时挂起，保存运行状态.相当于在yield那一句弄了个断点在函数中，yield的作用有俩： 1.赋值功能：外界send(arg),把当前的yield赋值为arg，接着继续运行函数 2.返回结果功能：函数运行到新的yield时返回此时yield后的值&#x27;&#x27;&#x27;def test(): print(&#x27;before&#x27;) while True: x = yield print(x)# &#x27;赋值功能演示&#x27;# g1 = test()#因为yield函数的调用结果变为一个生成器# next(g1)#等同于g1.send(none),初始化生成器，使生成器停止在x=yield那一步（这一步还没运行完成，只会先返回yield后的值，相当于是一个初始状态了）# g1.send(&#x27;hahaha&#x27;)#函数接着上一步运行x=yield,send的功能是把参数传给yield。然后函数本身又执行x=yield的赋值操作，所以最后# #对x的打印结果就是传进去的参数。接着函数运行到新的x=yield(这一句还没运行)时因遇到新的yield而暂时挂起。等待下一次对这个生成器的调用# g1.send(&#x27;xixixi&#x27;)&#x27;返回值功能演示&#x27;def test2(): food_list = [] while True: food = yield food_list food_list.append(food) print(f&#x27;此次传参：&#123;food&#125;&#x27;)g2 = test2()g2.send(None)#初始化生成器,停在food = yield food_list(这一步还没运行完成，只会先返回yield后的值，即返回[],相当于是一个初始状态了)print(g2.send(&#x27;apple&#x27;))#首先传值，再继续运行函数，直到遇到新的yield，返回yield后面跟着的food_list。 #之后函数再继续挂起，下一次运行时，函数的状态就是现在的状态。。 # 注意：顺序是传值-运行函数-返回结果，遇到yield就挂起函数print(g2.send(&#x27;banana&#x27;))print(g2.send([&#x27;apple&#x27;, &#x27;banana&#x27;])) 反射机制1234567891011121314151617181920212223# 本质就是通过字符串操作对象.出来的属性# 实现反射机制的步骤# 1、先通过dir：查看出某一个对象下可以.出哪些属性来# print(dir(obj))# 2、可以通过字符串反射到真正的属性上，得到属性值# print(obj.__dict__[dir(obj)[-2]]) 对象的属性值都存在__dict__这个字典里# 四个内置函数的使用:通过字符串来操作属性值# 1、hasattr()# print(hasattr(obj,&#x27;name&#x27;))# print(hasattr(obj,&#x27;x&#x27;))# 2、getattr()# print(getattr(obj,&#x27;name&#x27;))# 3、setattr()# setattr(obj,&#x27;name&#x27;,&#x27;EGON&#x27;) # obj.name=&#x27;EGON&#x27;# print(obj.name)# 4、delattr()# delattr(obj,&#x27;name&#x27;) # del obj.name# print(obj.__dict__)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"hexo搭建","slug":"hexo笔记","date":"2023-02-03T07:44:20.000Z","updated":"2023-02-04T01:46:56.386Z","comments":true,"path":"2023/02/03/hexo笔记/","link":"","permalink":"http://example.com/2023/02/03/hexo%E7%AC%94%E8%AE%B0/","excerpt":"","text":"hexo搭建参考博客：hexo博客搭建即可。写得挺好，但是有些地方没有说明白，在下面补充一下。 配置hexo补充说明 虽然启动的时候在本地是http://localhost:4000.com,,但是你用https://username.github.io也能访问 clone下来的主题要放在hexo根目录下的themes文件夹中才有效。否则会出现读取文件时读到null对象的情况 clone下来的文件夹的名字要改为主题名字，比如clone下来的文件夹是hexo-theme-nexmoe，那么就要改成nexmoe。否则会出现index.html no layout的报错 source资源文件夹： 是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown(会被解析成html) 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。而public文件夹就相当于服务器向外界中开放的资源，里面的内容可以通过/文件名进行访问。 特别的，如果你要开放一张图片的资源(以微信二维码为例)，那么首先你要把图片下载到source文件夹中，再在.yml配置文件中(或其他途径)将前端相应的链接改为/winxin.jpg,那样就可以通过前端页面访问到图片资源了。 网站的根目录就是source文件夹。所以在编写.md文件时，如果要应用图片的话，图片路径以/开头的话就是从source目录开始找文件 主题的配置文件要在对应的主题根目录下的_config.yml修改才有效。其中配置文件中的/文件名就是访问的source中的文件。如果修改了不生效，可以先把hexo根目录下的对应主题的配置文件删了，再用hexo g命令重新生成一份就好了","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-01T01:45:59.976Z","updated":"2023-02-04T01:19:08.967Z","comments":true,"path":"2023/02/01/hello-world/","link":"","permalink":"http://example.com/2023/02/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"system","slug":"system","permalink":"http://example.com/tags/system/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]}],"categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"django","slug":"code/python/django","permalink":"http://example.com/categories/code/python/django/"},{"name":"windows","slug":"code/windows","permalink":"http://example.com/categories/code/windows/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"system","slug":"system","permalink":"http://example.com/tags/system/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]}