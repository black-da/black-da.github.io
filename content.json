{"meta":{"title":"czw","subtitle":"subtitile of czw","description":"","author":"czw","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-02-03T03:23:49.649Z","updated":"2023-02-03T03:23:49.643Z","comments":true,"path":"about.html","permalink":"http://example.com/about.html","excerpt":"","text":"我是czw华电的计科的"},{"title":"文章归档","date":"2023-02-04T00:47:46.289Z","updated":"2023-02-02T09:13:35.800Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"","date":"2023-02-04T01:49:19.764Z","updated":"2023-02-04T01:49:19.764Z","comments":true,"path":"PY.html","permalink":"http://example.com/PY.html","excerpt":"","text":"四海之内皆兄弟哈哈哈"},{"title":"","date":"2023-02-04T01:52:25.025Z","updated":"2023-02-04T01:52:25.025Z","comments":true,"path":"donate.html","permalink":"http://example.com/donate.html","excerpt":"","text":""}],"posts":[{"title":"Python基础","slug":"深浅拷贝","date":"2023-02-05T06:32:01.099Z","updated":"2023-02-05T06:36:32.432Z","comments":true,"path":"2023/02/05/深浅拷贝/","link":"","permalink":"http://example.com/2023/02/05/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"python不同类型的变量为何可以互相赋值python的一切变量都是指着一个地址，由于地址(也可理解为指针)的大小和类型(都是无符号整数)都是一样的，所以不同类型的变量可以相互赋值，本质上就是地址之间的赋值。 浅拷贝浅拷贝就是复制一份原来地址指向的第一块空间，并给一个新地址指向那份空间的副本，把新地址赋值给新变量。由于浅拷贝只是复制了地址指向的第一块空间，所以如果这个空间存的是不可变对象，那就是真正地拷贝了(即修改不会影响原变量的内容)；但如果存的是可变对象的引用，那么改变了这个对象的内容会影响到原变量的内容的 如果浅拷贝的内容是不可变类型，那么新变量指向的地址和原变量是一样的，因为不可变类型是常量，在系统中只要存一份就可以了。如果是可变类型，就会申请一个新地址，指向原变量的顶层引用的副本 函数传参就是传一个浅拷贝过去 深拷贝深拷贝是递归拷贝，就是申请一个新地址，并把原变量的所有内容都拷贝一份","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"python基础","slug":"code/python/python基础","permalink":"http://example.com/categories/code/python/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Python文件操作","slug":"文件操作","date":"2023-02-05T06:28:21.074Z","updated":"2023-02-05T06:31:10.195Z","comments":true,"path":"2023/02/05/文件操作/","link":"","permalink":"http://example.com/2023/02/05/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"编码和解码123456789101112131415编码和解码是str和bytes之间的转换bytes.decode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;) Return the bytes decoded to a str.str.encode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;) Return the string encoded to bytes.a = &#x27;上&#x27;# python默认用unicode编码b = a.encode(&#x27;utf-8&#x27;) #用utf-8的编码方式： utf-8的str ==&gt; byteprint(b, type(b))c = b.decode(&#x27;utf-8&#x27;) #用utf-8的解码方式： byte ==&gt; utf-8的strprint(c, type(c))# b&#x27;\\xe4\\xb8\\x8a&#x27; &lt;class &#x27;bytes&#x27;&gt;# 上 &lt;class &#x27;str&#x27;&gt; 文件操作1234567891011121314151617181920212223242526272829303132333435363738394041424344路径问题：# 解决方案一：推荐。用Python的raw字符串避免所有转义# open(r&#x27;C:\\a.txt\\nb\\c\\d.txt&#x27;)# 解决方案二：用/代替\\# open(&#x27;C:/a.txt/nb/c/d.txt&#x27;)with上下文管理，可以自动在最后执行f.close()关闭文件with open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;) as f1,\\ #用\\来完成一条语句的换行 open(&#x27;b.txt&#x27;,mode=&#x27;rt&#x27;) as f2: 指定字符编码强调：t和b不能单独使用，必须跟r/w/a连用t文本（默认的模式） 1、读写都以str（unicode）为单位的 2、文本文件 3、必须指定encoding=&#x27;utf-8&#x27;# 没有指定encoding参数操作系统会使用自己默认的编码# linux系统默认utf-8# windows系统默认gbkwith open(&#x27;c.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f: 模式详解1、r（默认的操作模式）：只读模式，当文件不存在时报错，当文件存在时文件指针跳到开始位置2、w：只写模式，当文件不存在时会创建空文件，当文件存在会清空文件，指针位于开始位置 2.1、在以w模式打开文件没有关闭的情况下，连续写入，新的内容总是跟在旧的之后 2.2、如果重新以w模式打开文件，则会清空文件内容3、a：只追加写，在文件不存在时会创建空文件，在文件存在时文件指针会直接调到末尾t与b模式的区别：1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节(内部帮我们编码和解码)，b模式则需要手动编码与解码，所以此时t模式更为方便2、针对非文本文件（如图片、视频、音频等）只能使用b模式在读取文件时，为防止文件过大导致内存不够，通常用for循环读取with open(r&#x27;&#123;&#125;&#x27;.format(src_file),mode=&#x27;rb&#x27;) as f1,\\ open(r&#x27;&#123;&#125;&#x27;.format(dst_file),mode=&#x27;wb&#x27;) as f2: for line in f1: f2.write(line) 文本转二进制看《编码和解码》模块","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"python基础","slug":"code/python/python基础","permalink":"http://example.com/categories/code/python/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"Python基础","slug":"数据类型","date":"2023-02-05T06:16:07.882Z","updated":"2023-02-05T06:38:01.086Z","comments":true,"path":"2023/02/05/数据类型/","link":"","permalink":"http://example.com/2023/02/05/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"字符串格式化输出12345678910111213141516171819202122232425262728293031323334353637str.format:兼容性好# 按照位置传值# res=&#x27;我的名字是 &#123;&#125; 我的年龄是 &#123;&#125;&#x27;.format(&#x27;czw&#x27;,18)# res=&#x27;我的名字是 &#123;0&#125;&#123;0&#125;&#123;0&#125; 我的年龄是 &#123;1&#125;&#123;1&#125;&#x27;.format(&#x27;czw&#x27;,18)# 打破位置的限制，按照key=value传值# res=&quot;我的名字是 &#123;name&#125; 我的年龄是 &#123;age&#125;&quot;.format(age=18,name=&#x27;czw&#x27;)填充与格式化!!先取到值,然后在冒号后设定填充格式：[填充字符][对齐方式][宽度]!!# *&lt;10：左对齐，总共10个字符，不够的用*号填充print(&#x27;&#123;0:*&lt;10&#125;&#x27;.format(&#x27;开始执行&#x27;)) # 开始执行******# *&gt;10：右对齐，总共10个字符，不够的用*号填充print(&#x27;&#123;0:*&gt;10&#125;&#x27;.format(&#x27;开始执行&#x27;)) # ******开始执行# *^10：居中显示，总共10个字符，不够的用*号填充print(&#x27;&#123;0:*^10&#125;&#x27;.format(&#x27;开始执行&#x27;)) # ***开始执行***精度与进制print(&#x27;&#123;salary:.3f&#125;&#x27;.format(salary=1232132.12351)) #精确到小数点后3位，四舍五入，结果为：1232132.124print(&#x27;&#123;0:b&#125;&#x27;.format(123)) # 转成二进制，结果为：1111011print(&#x27;&#123;0:o&#125;&#x27;.format(9)) # 转成八进制，结果为：11print(&#x27;&#123;0:x&#125;&#x27;.format(15)) # 转成十六进制，结果为：fprint(&#x27;&#123;0:,&#125;&#x27;.format(99812939393931)) # 千分位格式化，结果为：99,812,939,393,931# 2.3 f:python3.5以后才推出x = input(&#x27;your name: &#x27;)y = input(&#x27;your age: &#x27;)res = f&#x27;我的名字是&#123;x&#125; 我的年龄是&#123;y&#125;&#x27;# raw字符串：取消所有的转义r&#x27;\\n&#x27;表示2个字符&#x27;\\&#x27;和&#x27;n&#x27;,而不是换行 r&#x27;&#123;&#125;&#x27;.format(src_file) #raw只针对转义，不针对&#123;&#125;，format方法还是可以使用的 常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990按索引取值(正向取+反向取) ：只能取，不能改，因为str是常量msg=&#x27;hello world&#x27;# 正向取# print(msg[0])# 反向取# print(msg[-1])#切片.相当于浅拷贝copy，只拷贝顶层引用# res=msg[0:5]# 步长msg = &#x27;hello world&#x27;# res=msg[0:5:2] # 0 2 4# 反向步长# res=msg[5:0:-1] #5 4 3 2 1# print(res) #&quot; olle&quot;移除字符串左右两侧的符号strip、lstrip、rstrip# 默认去掉的空格# msg=&#x27; czw &#x27;# res=msg.strip()# print(msg) # 不会改变原值# print(res) # 是产生了新值# 可指定移除的字符# msg=&#x27;****czw****&#x27;# print(msg.strip(&#x27;*&#x27;))切分split：把一个字符串按照某种分隔符进行切分，得到一个列表。rsplit# # 默认分隔符是空格# info=&#x27;czw 18 male&#x27;# res=info.split()# # 指定分隔符# info=&#x27;czw:18:male&#x27;# res=info.split(&#x27;:&#x27;)# 指定分隔次数(了解)# info=&#x27;czw:18:male&#x27;# res=info.split(&#x27;:&#x27;,1)lower,upper# msg=&#x27;AbbbCCCC&#x27;# print(msg.lower())# print(msg.upper())startswith,endswith# print(&quot;alex is sb&quot;.startswith(&quot;alex&quot;))# print(&quot;alex is sb&quot;.endswith(&#x27;sb&#x27;))join: 把可迭代对象里的字符串元素拼接成字符串# l=[&#x27;czw&#x27;, &#x27;18&#x27;, &#x27;male&#x27;]# res=&quot;:&quot;.join(l) # 按照某个分隔符号，把元素全为字符串的列表拼接成一个大字符串replace# msg=&quot;you can you up no can no bb&quot;# print(msg.replace(&quot;you&quot;,&quot;YOU&quot;,))# print(msg.replace(&quot;you&quot;,&quot;YOU&quot;,1))isdigit# 判断字符串是否由整数组成# print(&#x27;123&#x27;.isdigit()) True# print(&#x27;12.3&#x27;.isdigit()) Falsefind,rfind,index,rindexmsg=&#x27;hello czw hahaha&#x27;# 找到返回起始索引# print(msg.find(&#x27;e&#x27;)) # 返回要查找的字符串在大字符串中的起始索引# print(msg.find(&#x27;czw&#x27;))# print(msg.index(&#x27;e&#x27;))# print(msg.index(&#x27;czw&#x27;))# 找不到# print(msg.find(&#x27;xxx&#x27;)) # 返回-1，代表找不到# print(msg.index(&#x27;xxx&#x27;)) # 抛出异常count# msg=&#x27;hello czw hahaha czw、 czw&#x27;# print(msg.count(&#x27;czw&#x27;))is系列# print(&#x27;abc&#x27;.islower())# print(&#x27;ABC&#x27;.isupper())# print(&#x27;123123aadsf&#x27;.isalnum()) # 字符串由字母或数字组成结果为True# print(&#x27;ad&#x27;.isalpha()) # 字符串由由字母组成结果为True# print(&#x27; &#x27;.isspace()) # 字符串由空格组成结果为True 列表常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950追加# l=[111,&#x27;czw&#x27;,&#x27;hello&#x27;]# l.append(3333)# l.append(4444)# print(l)插入值# l=[111,&#x27;czw&#x27;,&#x27;hello&#x27;]# l.insert(0,&#x27;alex&#x27;)# print(l)extend拓展列表# new_l=[1,2,3]# l=[111,&#x27;czw&#x27;,&#x27;hello&#x27;]# l.extend(new_l)# print(l) [111, &#x27;czw&#x27;, &#x27;hello&#x27;, 1, 2, 3]删除# 方式一：通用的删除方法，只是单纯的删除、没有返回值# l = [111, &#x27;czw&#x27;, &#x27;hello&#x27;]# del l[1]# 方式二：l.pop()根据索引删除，会返回删除的值# l = [111, &#x27;czw&#x27;, &#x27;hello&#x27;]# l.pop() # 不指定索引默认删除最后一个# print(l)# 方式三：l.remove()根据元素删除，返回None# l = [111, &#x27;czw&#x27;, [1,2,3],&#x27;hello&#x27;]# l.remove([1,2,3])需要掌握操作l = [1, &#x27;aaa&#x27;, &#x27;bbb&#x27;,&#x27;aaa&#x27;,&#x27;aaa&#x27;]#l.count(&#x27;aaa&#x27;)# print(l.index(&#x27;aaa&#x27;))# print(l.index(&#x27;aaaaaaaaa&#x27;)) # 找不到报错# l.clear()# l.reverse():不是排序，就是将列表倒过来# l.sort(): 列表内元素必须是同种类型才可以排序# l=[11,-3,9,2,3.1]# l.sort() # 默认从小到大排，称之为升序# l.sort(reverse=True) # 从大到小排，设置为降序 元组常用方法1234567按照索引/位置存放多个值，只用于读不用于改。如果元组中只有一个元素，必须加逗号索引取值t.index(ele)# 获得指定元素的索引t.count(ele)# 获得指定元素在元组中的个数 字典常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748value可以是任意类型，但是key必须是不可变类型,且不能重复造字典的方式一：# d=&#123;&#x27;k1&#x27;:111, (1,2,3):222&#125;造字典的方式二：# d=dict(x=1,y=2,z=3)造字典的方式三：# info=[# [&#x27;name&#x27;,&#x27;czw&#x27;],# (&#x27;age&#x27;,18),# [&#x27;gender&#x27;,&#x27;male&#x27;]# ]# res=dict(info)按key存取值：可存可取# d=&#123;&#x27;k1&#x27;:111&#125;# 针对赋值操作：key存在，则修改# d[&#x27;k1&#x27;]=222# 针对赋值操作：key不存在，则创建新值# d[&#x27;k2&#x27;]=3333成员运算in和not in:根据key# d=&#123;&#x27;k1&#x27;:111,&#x27;k2&#x27;:2222&#125;# print(&#x27;k1&#x27; in d)# print(111 in d)#4、删除d=&#123;&#x27;k1&#x27;:111,&#x27;k2&#x27;:2222&#125;# 4.1 通用删除# del d[&#x27;k1&#x27;]# 4.2 pop删除：根据key删除元素，返回删除key对应的那个value值# res=d.pop(&#x27;k2&#x27;)# 4.3 popitem删除：随机删除，返回元组(删除的key,删除的value)# res=d.popitem()键keys()，值values()，键值对items()d=&#123;&#x27;k1&#x27;:111&#125;#1、d.clear()#2、d.update()：根据参数扩展字典，如果原字典无则添加；如原字典有，若一样则不变，不一样则修改d.update(&#123;&#x27;k2&#x27;:222,&#x27;k3&#x27;:333&#125;) #&#123;&#x27;k1&#x27;: 111, &#x27;k2&#x27;: 222, &#x27;k3&#x27;: 333&#125;print(d)#3、d.get() ：根据key取值，容错性好# print(d[&#x27;k2&#x27;]) # key不存在则报错 集合常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960在&#123;&#125;内用逗号分隔开多个元素，多个元素满足以下三个条件# 1. 集合内元素必须为不可变类型# 2. 集合内元素无序# 3. 集合内元素没有重复# 4.1 取交集：两者共同的好友# res=friends1 &amp; friends2# print(res)# print(friends1.intersection(friends2))# 4.2 取并集/合集：两者所有的好友# print(friends1 | friends2)# print(friends1.union(friends2))# 4.3 取差集：取friends1独有的好友# print(friends1 - friends2)# print(friends1.difference(friends2))# 取friends2独有的好友# print(friends2 - friends1)# print(friends2.difference(friends1))# 4.4 对称差集: 求两个用户独有的好友们（即去掉共有的好友）# print(friends1 ^ friends2)# print(friends1.symmetric_difference(friends2))# 4.5 父子集：包含的关系# s1=&#123;1,2,3&#125;# s2=&#123;1,2,4&#125;# 不存在包含关系，下面比较均为False# print(s1 &gt; s2)# print(s1 &lt; s2)# s1=&#123;1,2,3&#125;# s2=&#123;1,2&#125;# print(s1 &gt; s2) # 当s1大于或等于s2时，才能说是s1是s2他爹# =========================去重=========================# 1、只能针对不可变类型去重,即可迭代对象中的元素为不可变类型# print(set([1,1,1,1,2])) ==》｛1,2｝# print(set([[1, ],1,1,1,2])) ==》error,因为[1, ]不是不可变类型# 2、无法保证原来的顺序# l=[1,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;z&#x27;,1,1,1,2]# l=list(set(l))# 需要掌握的内置方法1：discard# s.discard(4) # 删除元素不存在do nothing# s.remove(4) # 删除元素不存在则报错# 需要掌握的内置方法2：update：与字典的update的用法一致# s.update(&#123;1,3,5&#125;)# 需要掌握的内置方法3：pop：随机弹出一个值，返回弹出的值# res=s.pop()# 需要掌握的内置方法4：add：添加一个值# s.add(4)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"python基础","slug":"code/python/python基础","permalink":"http://example.com/categories/code/python/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"Python基础","slug":"python基础","date":"2023-02-05T06:07:16.750Z","updated":"2023-02-05T06:37:21.159Z","comments":true,"path":"2023/02/05/python基础/","link":"","permalink":"http://example.com/2023/02/05/python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Pycharm激活码：IHMWLMSEAL-eyJsaWNlbnNlSWQiOiJJSE1XTE1TRUFMIiwibGljZW5zZWVOYW1lIjoidHJlbmRzIHJhYmJpcyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IlBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUFBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wMi0wOCIsInBhaWRVcFRvIjoiMjAyMy0wMi0wOCIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDItMDgiLCJwYWlkVXBUbyI6IjIwMjMtMDItMDgiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTAyLTA4IiwicGFpZFVwVG8iOiIyMDIzLTAyLTA4IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjIwMjA4UFNBTjAwMDAwNSIsImhhc2giOiJUUklBTDozMzQzMzQ3ODMiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-TT&#x2F;mvlYqIE07j8qgnrhSSVpMtD4buKsRuntPuB17Zb8KodU2SUcb8byLpLG1pU+xEIIyG3Scu&#x2F;ypjXmQ9w4iyvOT+NYGmeeHFMHnknQVEhhUvDZjTMNXPct03KeHcjxJX8jMSsuRkTooePx1beXjHTuxcyiO8qJcNOOl&#x2F;97pT45kGTqSJohat0Xe7oiwrE6u3JZhfSdmYV9iJxz6XGNeoPMPnXbH17yoP75eXUqQJzUGxqdeHyKVHSUUJTGfO3IHgjN9y2TwYET5oFjRy1qSMRf4vXpPCK7tnfqhCGISQiDCm+ETB133CcmArxlRVlKdbAIM&#x2F;7W++eOn5AfW&#x2F;CNvgg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU&#x2F;Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8&#x2F;COMrxRlZW5mfzo0xsK0dQGNH3UoG&#x2F;9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE&#x2F;BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5&#x2F;FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB&#x2F;R5oUlebwaTE6WZNBs+TA&#x2F;qPj+5&#x2F;we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329&#x2F;WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V&#x2F;0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ&#x2F;c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0&#x2F;&#x2F;lOmVya&#x2F;PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0&#x2F;WFPl1aw5VV&#x2F;VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH&#x2F;0onD 类 类中属性查找的顺序：对象&#x3D;&gt;类&#x3D;&gt;父类 浅拷贝浅拷贝就是复制一份原来地址指向的第一块空间，并给一个新地址指向那份空间的副本，把新地址赋值给新变量。由于浅拷贝只是复制了地址指向的第一块空间，所以如果这个空间存的是不可变对象，那就是真正地拷贝了(即修改不会影响原变量的内容)；但如果存的是可变对象的引用，那么改变了这个对象的内容会影响到原变量的内容的 如果浅拷贝的内容是不可变类型，那么新变量指向的地址和原变量是一样的，因为不可变类型是常量，在系统中只要存一份就可以了。如果是可变类型，就会申请一个新地址，指向原变量的顶层引用的副本 函数传参就是传一个浅拷贝过去 深拷贝深拷贝是递归拷贝，就是申请一个新地址，并把原变量的所有内容都拷贝一份 字符编码 ascii码是一开始美国采用的编码，只有1个字节的大小，表示256种字符，为字母和标点符号 gbk是中文编码 unicode是万国码，但它只做了字符和数字的对应关系，而没有规定存储方式，utf-8就是unicode编码的一种存储方式，即可变长的存储，简单字符用少字节，复杂字符用多字节存储 闭包函数闭包函数时一种广泛的叫法，存在于所有的编程语言中，只要符合以下2点就是闭包函数： 闭包函数定义在其他函数的内部 闭包函数对外部作用域有引用 123456789101112131415161718装饰器就是闭包函数的一个典型应用：def wrapper(func): def inner(*args, **kwargs): # code res = func(*args, **kwargs) # code return res return innerdef a(): print(hello)a = wrapper(a)# 把b当作参数传入wrapper，并把返回值赋给b@wrapperdef b(): print(hello) 魔法方法 魔法方法就是满足了特定条件会自动触发的方法 12345678# __init__：类实例化会触发# __str__:打印对象会触发# __call__:对象()触发类的__call__()。让对象可以像函数一样被调用。类也是对象，类(),类的实例化过程调用元类的__call__。# __new__:在类实例化会触发，它比__init__早,创造对象用的，有点复杂# __del__:del 对象，对象回收的时候触发# __setattr__,__getattr__:(.拦截方法)，当对象.属性触发--&gt;赋值会调用setattr，取值只有引发AttributeError才会调用getattr# __getitem__,__setitem__:([]拦截)，当对象[属性]触发--&gt;赋值会调用setitem，取值会调用getitem# __enter__和__exit__ 上下文管理器 setattr，getattr，setitem，getitem演示 1234567891011121314# class Person:# def __init__(self,name):# self.name=name# def __setitem__(self, key, value):# setattr(self,key,value) #反射# def __getitem__(self, item):# return getattr(self,item) # 反射取值## p=Person(&#x27;lqz&#x27;)# # p.name=&#x27;ppp&#x27;# p[&#x27;name&#x27;]=10 # 如何实现 重写__setitem__魔法方法# # print(p.name)## print(p[&#x27;name&#x27;]) _eq_ 12345678910111213141516171819class A: def __init__(self,x,y): self.x = x self.y = y def __eq__(self,obj): # 打印出比较的第二个对象的x值 print(obj.x) if self.x +self.y == obj.x+obj.y: return True else: return Falsea=A(1,2)b=A(99,3)print(a==b)print(a==&#x27;ddd&#x27;) # 当执行==s时，会触发__eq__的执行，并且把b传进去，就是object# ==后只要是对象，就可以传进去，就是object pymysql的使用1234567891011121314151617181920212223242526import pymysql#连接数据库conn=pymysql.connect(host=&#x27;101.133.225.166&#x27;, user=&#x27;root&#x27;, password=&quot;123456&quot;,database=&#x27;test&#x27;, port=3306)# 获取游标cursor=conn.cursor(cursor=pymysql.cursors.DictCursor) # 查出来数据是字典格式# 操作 定义一个sql# sql=&#x27;select id,name from book&#x27;# cursor.execute(sql)# ret=cursor.fetchall()# print(ret)# 插入# sql=&#x27;insert into book(id,name) values (%s,%s)&#x27;# cursor.execute(sql,[3,&#x27;lqz&#x27;])# conn.commit()# 删除# sql=&#x27;delete from book where name=%s&#x27;# cursor.execute(sql,[&#x27;lqz&#x27;])# conn.commit()# 更新# sql=&#x27;update book set name=%s where id=%s&#x27;# cursor.execute(sql,[&#x27;xxx&#x27;,1])# conn.commit() 字典传参1**dict传值，可以等同于**kwargs，将字典打散按关键字传值 包的导入12345678910111213141516171819202122232425262728293031323334&#x27;&#x27;&#x27;1、包就是一个包含有__init__.py文件的文件夹2、为何要有包 包的本质是模块的一种形式，包是用来被当做模块导入&#x27;&#x27;&#x27;导入包实际的运行情况#1、产生一个名称空间#2、运行包下的__init__.py文件（如果导入的是模块就是运行模块名.py文件），将运行过程中产生的名字都丢到1的名称空间中#3、在当前执行文件的名称空间中拿到一个名字‘模块名’，‘模块名’指向1的名称空间# from mmm import x# 环境变量是以执行文件为基准的，所有的被导入的模块或者说后续的其他文件引用的sys.path都是参照执行文件的sys.path，即path的第一个元素都是执行文件所在的文件夹的路径# 强调：# 1.关于包相关的导入语句也分为import和from ... import ...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：# 凡是在导入时带点的，点的左边都必须是一个包，否则非法。# 可以带有一连串的点，如import 顶级包.子包.子模块,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。# 例如：# from a.b.c.d.e.f import xxx# import a.b.c.d.e.f# 其中a、b、c、d、e 都必须是包# 2、包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间## 3、import导入文件时，产生名称空间中的名字来源于文件，# import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件相对导入：.表示当前文件所在文件夹。..表示上一层文件夹。相对导入一般用于包内模块的相互引用from .mm import f1表示导入位于当前文件所在文件夹的mm.py中的函数f1 模块操作(包的操作同理)： 导入模块： a) 全部导入：import moduleName b) 从模块种导入指定函数：from module impore func1(,func2….) Python在查找模块导入时，遵循以下查找顺序： a) 先查找内存中已经加载好的模块 b) 再查找python的内置模块 c) 最后查找sys.path路径中包含的模块 对system..path的操作： a) sys.path是一个列表，它的第一个路径是当前执行文件所在的文件夹 b) 如果要将不存在于该文件夹的模块导入，要将该模块的路径添加到system.path。 如将func3导入文件： import sys sys.path.append(“func3的路径比如桌面：C:\\Users\\Desktop”)#导入后，python会在你导入func3时在该路径下查找func3的文件 import func3 环境变量的作用：Windows中如果你要在命令行中执行某个文件，那么系统会先在目前所在的文件夹中检索看这个文件在不在，在的话就执行；不在的话就在Windows的环境变量(是一个存放着各种文件夹路径的列表)中存放的文件夹下去检索目标文件，找到就执行，还找不到就说找不到了。 重复文件名问题：系统在环境变量存放的文件夹中检索文件时，会按照列表中从上到下的顺序检索文件夹，所以如果2个文件夹里有同名文件，那么系统只会找到存放在上面的那个文件夹的文件执行。解决方案是：各复制一份这个重复名字的文件的副本，再分别进行重命名(直接改名字而不复制可能会受到限制不给重命名) 环境变量的设置：我的电脑-》属性-》高级系统设置-》环境变量-》添加新的文件夹路径(比如C:\\) 小技巧lambda表达式匿名函数lambda用于临时调用一次的场景：更多的是将匿名函数与其他函数配合使用 lambda 参数: 返回值 12345678910111213141516171819202122232425应用场景：某些函数里需要一些经过简单处理后的数据，那么这个简单处理的过程就可以用lambda更为简便地实现。比如max(iterable, *, key=None)函数中，key实参指定排序函数用的参数。返回可迭代对象中最大的元素salaries=&#123; &#x27;siry&#x27;:3000, &#x27;tom&#x27;:7000, &#x27;lili&#x27;:10000, &#x27;jack&#x27;:2000&#125;# 迭代出的内容 比较的值# &#x27;siry&#x27; 3000# &#x27;tom&#x27; 7000# &#x27;lili&#x27; 10000# &#x27;jack&#x27; 2000问题就是key默认是迭代出的内容，但我们希望key是salaries[迭代出的内容]，即薪水的资料，这时就可以用lambda简单的处理一下# def func(k):# return salaries[k]# res=max(salaries,key=func) # 返回值=func(&#x27;siry&#x27;) #这是key需要的就是salaries[迭代的内容]这样处理过的数据。这里func会自动以迭代出的内容作为参数执行，再把返回值赋给key# res=max(salaries,key=lambda k:salaries[k]) 这时lambda等同于func，但明显func还要单独定义啥的，比较复杂，不如lambda简单。这里的k默认就是迭代出的内容。注意，这里返回的res是满足条件的可迭代对象，而不是最大的比较的值还可应用于列表排序：a = [(1, 2), (4, 1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1]) 三元表达式12expression1 if condition else expression2x = 1 if 1 &gt; 3 else 3 生成式1234567891011121、列表推导式 [i*2 for i in [1, 2]]2、字典生成式# items=[(&#x27;name&#x27;,&#x27;egon&#x27;),(&#x27;age&#x27;,18),(&#x27;gender&#x27;,&#x27;male&#x27;)]# res=&#123;k:v for k,v in items if k != &#x27;gender&#x27;&#125;3、集合生成式# keys=[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;gender&#x27;]# set1=&#123;key for key in keys&#125;4、生成器表达式# g=(i for i in range(10) if i &gt; 3) yield解析12345678910111213141516171819202122232425262728293031323334353637383940&#x27;&#x27;&#x27;yield函数解析：yield出现在函数中会使函数的调用结果变为一个生成器.这样的函数可以暂时挂起，保存运行状态.相当于在yield那一句弄了个断点在函数中，yield的作用有俩： 1.赋值功能：外界send(arg),把当前的yield赋值为arg，接着继续运行函数 2.返回结果功能：函数运行到新的yield时返回此时yield后的值&#x27;&#x27;&#x27;def test(): print(&#x27;before&#x27;) while True: x = yield print(x)# &#x27;赋值功能演示&#x27;# g1 = test()#因为yield函数的调用结果变为一个生成器# next(g1)#等同于g1.send(none),初始化生成器，使生成器停止在x=yield那一步（这一步还没运行完成，只会先返回yield后的值，相当于是一个初始状态了）# g1.send(&#x27;hahaha&#x27;)#函数接着上一步运行x=yield,send的功能是把参数传给yield。然后函数本身又执行x=yield的赋值操作，所以最后# #对x的打印结果就是传进去的参数。接着函数运行到新的x=yield(这一句还没运行)时因遇到新的yield而暂时挂起。等待下一次对这个生成器的调用# g1.send(&#x27;xixixi&#x27;)&#x27;返回值功能演示&#x27;def test2(): food_list = [] while True: food = yield food_list food_list.append(food) print(f&#x27;此次传参：&#123;food&#125;&#x27;)g2 = test2()g2.send(None)#初始化生成器,停在food = yield food_list(这一步还没运行完成，只会先返回yield后的值，即返回[],相当于是一个初始状态了)print(g2.send(&#x27;apple&#x27;))#首先传值，再继续运行函数，直到遇到新的yield，返回yield后面跟着的food_list。 #之后函数再继续挂起，下一次运行时，函数的状态就是现在的状态。。 # 注意：顺序是传值-运行函数-返回结果，遇到yield就挂起函数print(g2.send(&#x27;banana&#x27;))print(g2.send([&#x27;apple&#x27;, &#x27;banana&#x27;])) 反射机制1234567891011121314151617181920212223# 本质就是通过字符串操作对象.出来的属性# 实现反射机制的步骤# 1、先通过dir：查看出某一个对象下可以.出哪些属性来# print(dir(obj))# 2、可以通过字符串反射到真正的属性上，得到属性值# print(obj.__dict__[dir(obj)[-2]]) 对象的属性值都存在__dict__这个字典里# 四个内置函数的使用:通过字符串来操作属性值# 1、hasattr()# print(hasattr(obj,&#x27;name&#x27;))# print(hasattr(obj,&#x27;x&#x27;))# 2、getattr()# print(getattr(obj,&#x27;name&#x27;))# 3、setattr()# setattr(obj,&#x27;name&#x27;,&#x27;EGON&#x27;) # obj.name=&#x27;EGON&#x27;# print(obj.name)# 4、delattr()# delattr(obj,&#x27;name&#x27;) # del obj.name# print(obj.__dict__) 常用模块hashlib123456import hashlibm=hashlib.md5()m.update(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;))m.update(&#x27;world&#x27;.encode(&#x27;utf-8&#x27;))res=m.hexdigest() # &#x27;helloworld&#x27;的加密字符串 序列化模块(Json pickle)123456789101112131415161718序列化得到结果=&gt;特定的格式的内容 有两种用途1、可用于存储=》用于存档 采用一种专用的格式=》pickle只有python可以识别2、传输给其他平台使用=》跨平台数据交互 采用一种通用、能够被所有语言识别的格式=》json# 序列化json_res=json.dumps([1,&#x27;aaa&#x27;,True,False])print(json_res,type(json_res)) # &quot;[1, &quot;aaa&quot;, true, false]&quot;， str# 反序列化l=json.loads(json_res)将序列化的结果写入文件的简单方法with open(&#x27;test.json&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f: json.dump([1,&#x27;aaa&#x27;,True,False],f) # 普通的dumps方法去掉s而已 res = pickle.dumps([1.2, True, &#x27;acv&#x27;, [11, 2]])#pickle序列化后的类型是byteres2 = pickle.loads(res)with open(&#x27;test.pickle&#x27;, &#x27;rb&#x27;) as f: res = pickle.load(f) os123456789# 获取某一个文件夹下所有的子文件以及子文件夹的名字,只找最外面的1层# res=os.listdir(&#x27;.&#x27;)# os.remove() 删除一个文件# os.rename(&quot;oldname&quot;,&quot;newname&quot;) 重命名文件/目录os.path.isfile(r&#x27;aaa&#x27;)os.path.isdir(r&#x27;aaa&#x27;)os.path.join(&#x27;a&#x27;,&#x27;/&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)os.path.dirname(path) #获取path的目录路径__file__ #获取当前文件的绝对路径 random模块1234567random.random() #(0,1)----floatrandom.uniform(1, 3) # (1, 3)的小数random.randint(1, 3) # [1,3]random.randrange(1, 3) # [1,3)的整数random.choice([111, &#x27;aaa&#x27;, [4, 5]]) #列表中的三个元素取一个random.seed(10) #在每次用到随机值时可以通过设定seed来指定随机数 sys模块12345命令行中敲：python3.8 run.py 1 2 3 即运行当前目录下的run.py文件，传如参数1 2 3# sys.argv获取的是命令行中解释器后参数值sys.argv的值为[1, 2, 3]这个命令通常在用命令行调用python程序中使用 time模块123456789101112131415161718192021222324252627# 时间分为三种格式：# 1、时间戳：从1970年到现在经过的秒数# 作用：用于时间间隔的计算# print(time.time())# 2、按照某种格式显示的时间：2020-03-30 11:11:11# 作用：用于展示时间# print(time.strftime(&#x27;%Y-%m-%d %H:%M:%S %p&#x27;))# print(time.strftime(&#x27;%Y-%m-%d %X&#x27;))# 3、结构化的时间# 作用：用于单独获取时间的某一部分# res=time.localtime()# print(res) #time.struct_time(tm_year=2023, tm_mon=1, tm_mday=29, tm_hour=10, tm_min=47, tm_sec=45, tm_wday=6, tm_yday=29, tm_isdst=0)# print(res.tm_year)!!!真正需要掌握的只有一条：format string&lt;------&gt;timestamp&#x27;1988-03-03 11:11:11&#x27;+7format string---&gt;struct_time---&gt;timestampstruct_time=time.strptime(&#x27;1988-03-03 11:11:11&#x27;,&#x27;%Y-%m-%d %H:%M:%S&#x27;)timestamp=time.mktime(struct_time)+7*86400 # 时间戳加7天，可用于会员过期时间print(timestamp)format string&lt;---struct_time&lt;---timestampres=time.strftime(&#x27;%Y-%m-%d %X&#x27;,time.localtime(timestamp))print(res) 内置函数enumerate枚举123456789# enumerate枚举test_list = [1, 3, 5, 7, 9]for i, j in enumerate(test_list): print(i, j, sep=&#x27;\\t&#x27;) # i对应索引，j对应列表的内容。即可以取到索引和内容0 11 32 53 74 9 eval执行字符串中的表达式1234x = eval(&#x27;&#123;1, 3, 4&#125;&#x27;)print(type(x)) #dictprint(eval(&#x27;1+9&#x27;)) #10eval(&#x27;print(&quot;hahaha&quot;)&#x27;) #hahaha isinstance(obj, cls)判断obj是不是cls的实例12print(isinstance([1,2], list))print(isinstance([1,2], set)) zip(x, y)123456789101112131415#zip(x, y)拉链函数，将x，y索引相同的两个值组成一个元组，返回这些元组的列表x = [1, 2, 3, 4]y = (11, 22, 33, 44)print(type(zip(x, y)))#&lt;class &#x27;zip&#x27;&gt;for i, j in zip(x, y): #这里的i，j是自动解包的结果 print(i, j, sep=&#x27;\\t&#x27;)t = list(zip(x, y))print(t)&lt;class &#x27;zip&#x27;&gt;1 112 223 334 44[(1, 11), (2, 22), (3, 33), (4, 44)] 进制转换123bin(111)oct(111)hex(111) ascii字符12chr(65)ord(&#x27;a&#x27;)","categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"python基础","slug":"code/python/python基础","permalink":"http://example.com/categories/code/python/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"}]},{"title":"hexo搭建","slug":"hexo笔记","date":"2023-02-03T07:44:20.000Z","updated":"2023-02-04T01:46:56.386Z","comments":true,"path":"2023/02/03/hexo笔记/","link":"","permalink":"http://example.com/2023/02/03/hexo%E7%AC%94%E8%AE%B0/","excerpt":"","text":"hexo搭建参考博客：hexo博客搭建即可。写得挺好，但是有些地方没有说明白，在下面补充一下。 配置hexo补充说明 虽然启动的时候在本地是http://localhost:4000.com,,但是你用https://username.github.io也能访问 clone下来的主题要放在hexo根目录下的themes文件夹中才有效。否则会出现读取文件时读到null对象的情况 clone下来的文件夹的名字要改为主题名字，比如clone下来的文件夹是hexo-theme-nexmoe，那么就要改成nexmoe。否则会出现index.html no layout的报错 source资源文件夹： 是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown(会被解析成html) 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。而public文件夹就相当于服务器向外界中开放的资源，里面的内容可以通过/文件名进行访问。 特别的，如果你要开放一张图片的资源(以微信二维码为例)，那么首先你要把图片下载到source文件夹中，再在.yml配置文件中(或其他途径)将前端相应的链接改为/winxin.jpg,那样就可以通过前端页面访问到图片资源了。 网站的根目录就是source文件夹。所以在编写.md文件时，如果要应用图片的话，图片路径以/开头的话就是从source目录开始找文件 主题的配置文件要在对应的主题根目录下的_config.yml修改才有效。其中配置文件中的/文件名就是访问的source中的文件。如果修改了不生效，可以先把hexo根目录下的对应主题的配置文件删了，再用hexo g命令重新生成一份就好了","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-02-01T01:45:59.976Z","updated":"2023-02-04T01:19:08.967Z","comments":true,"path":"2023/02/01/hello-world/","link":"","permalink":"http://example.com/2023/02/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"system","slug":"system","permalink":"http://example.com/tags/system/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]}],"categories":[{"name":"code","slug":"code","permalink":"http://example.com/categories/code/"},{"name":"python","slug":"code/python","permalink":"http://example.com/categories/code/python/"},{"name":"python基础","slug":"code/python/python基础","permalink":"http://example.com/categories/code/python/python%E5%9F%BA%E7%A1%80/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"知识分享","slug":"知识分享","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"system","slug":"system","permalink":"http://example.com/tags/system/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]}